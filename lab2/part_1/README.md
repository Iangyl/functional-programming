# Рекурентні співвідношення для тригонометричних, експоненціальних функцій та ланцюгові дроби

Варіант 1<br />
Завдання 2.1

## Мета

Опанувати теоретичні основи застосування рекурентних співвідношень для обчислення тригонометричних, експоненціальних, степеневих функцій та розробити програми функціональними мовам програмування для обчислення їх значень.

## Умова задачі

Обчислити значення функції <i>у</i>, розвинувши функцію <i>cos(x)</i> у ряд Тейлора. Аргумент <i>x</i> змінюється від -2 до 2 з кроком 0.5. Визначити похибку.

![формула](https://github.com/Iangyl/functional-programming/blob/main/lab2/images/pic1.png)

## Обгрунтування вибору середовища та мови функціонального програмування

Середовище програмування: Visual Studio Code<br/><br/>
Мова функціонального програмування: Haskell<br/><br/>

Безкоштовний та зручний редактор коду, який можна використовувати майже для будь-якої мови програмування, а також можна використовувати в комерційних цілях.
Має широкий спектр налаштувань та можливостей, які надають плагіни, для поліпшення процесу розробки в плані комфорту та швидкості.<br/>

## Аналіз задачі

Формула, що виражає член послідовності через один або декілька попередніх, називається рекурентним співвідношенням. Послідовність, члени якої задовольняють деякому рекурентному співвідношенню, називається рекурентною.
<br/><br/>
У загальному випадку рекурентне співвідношення визначає залежність члена послідовності `{Sn}` від `k` попередніх членів: `Sn = F(Sn-k,…,Sn-1)`.
<br/><br/>
У задачі необхідно розвинути тригонометричну функцію `cos у` ряд Маклорена (Тейлора) за наступною формулою `1 – x^2/2! + x^4/4! – x^6/6! + …`.

## Код програми

```haskell
factorial :: Double -> Double
factorial 0 = 1
factorial n = n * factorial (n - 1)

uCos :: Double -> Double -> Double -> Double
uCos x n precision =
    if (x ** n) / factorial n > precision then (x ** n) / factorial n - uCos x (n + 2) precision
    else 0

y x
  | x >= -1 && x <= 0 = uCos (x / 2) 0 0.0001 / uCos (x ** 2) 0 0.0001
  | x > 0 = (uCos (x / 2) 0 0.0001 ** 2) * uCos (2 * x) 0 0.0001
  | otherwise = -11111111111

main = do 
    putStrLn "The error is:"
    let custom = uCos 5 1 0.00000000001
    let buildin = cos 5
    print (abs (custom - buildin))

    putStrLn "The result is:"
    print (map y [-2, -1.5 .. 2])
```

## Посилання на проект з вихідним кодом

https://github.com/Iangyl/functional-programming/blob/main/lab2/part_1/lab2.1.hs

## Результати

![результати](https://github.com/Iangyl/functional-programming/blob/main/lab2/images/results1.png)

## Висновки

В ході роботи було написано програму, що обчислює значення функції, розвинувши функцію cos(x) у ряд Тейлора. Аргумент х змінюється від -2 до 2 з кроком 0.5. Визначено похибку, як модуль різниці між значеннням користувацької та встроєної функцій.
